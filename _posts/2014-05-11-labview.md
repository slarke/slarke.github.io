---
layout: post
title: "state machine"
description: ""
category: 
tags: []
---
{% include JB/setup %}
<div class="embed-container"><iframe width="640" height="360" src="//www.youtube.com/embed/videoseries?list=PLHceeLHxBzTqTvYQL5pMVsEdqr1iUH_RJ" frameborder="0">&nbsp;</iframe></div>
Конечные автоматы(State machine) – наиболее разрекламированные шаблоны в LabVIEW. Существует множество вариаций, большинство из которых состоит из структуры Case, расположенной внутри цикла While, сдвиговым регистром или конструктом сообщений (альтернативная схема обмена данными между итерациями, соединенным с терминалом селектора структуры Case. Каждый случай структуры Case содержит субдиаграмму, соответствующую состоянию приложения. Селектор может быть целочисленного, строкового или пронумерованного типа данных (перечень) и будет определять состояния системы. Сдвиговый регистр или конструкт сообщений передает следующее, выбранное в предыдущем случае, состояние на терминал селектора на следующей итерации. Этот принцип проиллюстрирован на рис. 8.8, где используется классическая форма конечного автомата. В обычном приложении выбор состояния определен событием пользовательского интерфейса, шагом в последовательности тестов или измерений, или по результатам предыдущего состояния.
<br>
Конечный автомат – это невероятно гибкая структура с большими возможностями расширения. Сдвиговые регистры или другие конструкции сообщения позволяют перепрыгивать с одного любого состояния в любое другое. Каждое состояние может определять условия работы цикла While, так что его можно остановить в любом состоянии. Также вы легко можете добавить код в приложение, просто добавив случаи в структуру Case, без увеличения общего размера блок диаграммы.Эти особенности делают схему конечного автомата бесценной. Использовать эту схему в ВП среднего и высшего уровня сложности – беспроигрышный вариант.
<br>
Для того что бы использовать схему конечного автомата, приложение нужно разделить на серию состояний. Это можно сделать на стадии планирования, опираясь на требования, указанные в спецификации или проектной документации, или на стадии реализации, опираясь на опыт и интуицию. Как уже говорилось в главе 2 «Приготовка к хорошему стилю», чем тщательнее планирование, тем лучше конечный результат. Блок диаграмма конечного автомата – это ключевой компонент UML и идеальный метод определения основных состояний системы. Дополнительно доступна утилита от NI под названием State Diagram Toolkit, которая предоставляет редактор схем, по которым соответствующий код LabVIEW создается автоматически. Однако несколько применяемых в этой главе схем конечного автомата нельзя создать, используя State Diagram Toolkit. Вместо этого следует начинать с шаблонов.
<br>
Иногда функциональные состояния системы нельзя точно перевести на языкблок диаграмм LabVIEW, которые бы хорошо работали внутри схемы конечного автомата. По мере того как вы разрабатываете код, могут проявиться технические аспекты, которые приведут к другим очертаниям состояний. Например, данное функциональное состояние может иметь общую задачу с несколькими другими функциональными состояниями, что дает вам право разделить задачу на несколько различных случаев, так, чтобы к ним можно было обращаться из разных состояний. Если становится очевидным, что код в данном состоянии слишком большой для одного случая, не бойтесь создавать столько случаев, сколько необходимо. Помните о том, что ваш код должен состоять из модулей – ВПП, и определяйте состояния для возможности повторного использования. Для лучших результатов применяйте комбинацию планирования, опыта и интуиции.
<br>
Перечень, сохраненный как тайпдеф (type definition – определение типов), обеспечивает документацию и улучшает возможности поддержки. Когда перечень соединен с селектором структуры Case, то текстовые элементы перечня появляются в зоне селектора структуры Case. Используйте лаконичные и понятные имена для каждого состояния и вводите их как элементы перечня. Любые константы, созданные из тайпдефа, поддерживают синхронизацию имен элементов с тапдефом. Поэтому пронумерованные константы используются для определения следующего состояния в каждом случае. Когда элементы добавляются в перечень или удаляются из него, то соответствующие константы автоматически обновляются. Перечни, как тайпдеф, рекомендованы для всех вариаций шаблона конечного автомата, использующих структуру Case.
<br>
Для большинства приложений нужен код общего обслуживания: процедуры инициализации и выключения и, возможно, процедуры, которая выполняется тогда, когда больше ничего не выполняется. Например, какието значения и свойства управляющих задаются до выполнения любых тестов. Может также понадобиться обработчик ошибок или может быть запущена процедура опроса ресурсов, когда не обрабатываются никакие другие состояния. Процедура выключения необходима для того, чтобы корректно завершить все соединения с устройствами, файлами данных и удаленными приложениями. Создайте соответствующие состояния Initialize(Инициализация), Idle(Бездействие) и Shutdown (Выключение). Об этих процедурах вы могли и не задумываться на стадии планирования, но, по моему опыту, они нужны всегда. Используйте шаблон конечного автомата по максимуму и встройте эти процедуры как состояния конечного автомата, а не внешним кодом. Наконец, создайте состояние Blank (Пустое), содержащее передачу данных сдвиговых регистров в целях дублирования. Новые состояния можно будет добавить, скопировав это пустое состояние, это сэкономит время.
Например, блок диаграмма на рис. 8.9а содержит код инициализации и выключения в последовательных кадрах слева и справа от конечного автомата. Также конечный автомат опрашивает кнопку Stop слева от структуры Case и проверяет статус ошибки справа. Это неэффективное использование места. На рис. 8.9б содержится эквивалентный код, использующий конечный автомат с состояниями Инициализация, Бездействие, Выключение и Пустое. Два терминала сдвиговых регистров обеспечивают буфер, в котором хранится информация о двух следующих состояниях. Каждый раз, когда вызывается состояние Idle, оно добавляет другое состояние Idleв конец буфера, тем самым гарантируется, что состояние Idle чередуется с другими. Кроме того, состояние Idle проверяет статус кластера ошибок и останавливает цикл While, если происходит ошибка. Следовательно, блок диаграмма на рис. 8.9б эффективно использует место, заменив внешний код
<a href="http://imgur.com/jOKEl8n"><img src="http://i.imgur.com/jOKEl8n.png" title="Hosted by imgur.com" /></a>
<a href="http://imgur.com/gYRxjpo"><img src="http://i.imgur.com/gYRxjpo.png" title="Hosted by imgur.com" /></a>
<a href="http://imgur.com/Xw7tDdw"><img src="http://i.imgur.com/Xw7tDdw.png" title="Hosted by imgur.com" /></a>

<a href="http://1drv.ms/1nBceu5">http://1drv.ms/1nBceu5</a>

<a href="https://mega.co.nz/#F!ZoBBQSRb5">https://mega.co.nz/#F!ZoBBQSRb!V5-HCyGlZEB11mnYZA0ZqA</a>

